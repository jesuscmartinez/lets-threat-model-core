import logging
from typing import List, Optional
from uuid import UUID, uuid4

from pydantic import BaseModel, Field

from core.models.dtos.MitreAttack import Attack
from core.models.dtos.Threat import Threat
from core.models.dtos.File import File


logger = logging.getLogger(__name__)


class Component(BaseModel):
    """
    Represents a system component, which could be a process, data store, or external entity.
    """

    uuid: UUID = Field(default_factory=uuid4, description="UUID for the component.")
    name: str = Field(..., description="Name of the component (e.g., 'Login Flow').")
    description: str = Field(
        ..., description="Description of what the component represents."
    )

    def __hash__(self):
        return hash(self.uuid)

    def __eq__(self, other):
        return isinstance(other, Component) and self.uuid == other.uuid

    def model_dump(self, **kwargs):
        data = super().model_dump(**kwargs)
        data["uuid"] = str(self.uuid)

        return data

    def to_markdown(self) -> str:
        """
        Render this Component as a Markdown list item.
        """
        return f"- **{self.name}** (UUID: {self.uuid}): {self.description}"


class DataFlow(Component):
    """
    Describes a data flow between components, including its destination, type of data, and direction.
    """

    destination_uuid: UUID = Field(
        ..., description="The target component uuid of the data flow."
    )
    data_type: str = Field(
        default="",
        description="A description of the data being transferred (e.g., 'Product Review Data').",
    )
    direction: str = Field(
        default="",
        description="Indicates whether the flow is a read, incoming, outgoing, write or bidirectional relative to the source.",
    )

    def __hash__(self):
        return hash(self.uuid)

    def __eq__(self, other):
        return isinstance(other, DataFlow) and self.uuid == other.uuid

    def model_dump(self, **kwargs):
        data = super().model_dump(**kwargs)
        data["destination_uuid"] = str(self.destination_uuid)

        return data


class Node(Component):
    """
    Represents a node in the system that can have associated data flows.
    """

    data_flows: List[DataFlow] = Field(
        default_factory=list,
        description="Set of DataFlows associated with this external entity.",
    )

    def __hash__(self):
        return hash(self.uuid)

    def __eq__(self, other):
        return isinstance(other, Node) and self.uuid == other.uuid


class ExternalEntity(Node):
    """
    Represents an external entity that interacts with the system, such as a user or a third-party service.
    Inherits from Node, and thus can have associated data flows.
    """

    def __hash__(self):
        return hash(self.uuid)

    def __eq__(self, other):
        return isinstance(other, ExternalEntity) and self.uuid == other.uuid


class Process(Node):
    """
    Represents a process within the system that handles data.
    A process receives input data, performs actions, and produces output data.
    """

    input_data: List[str] = Field(
        default_factory=list,
        description="Specific data or triggers received by the process.",
    )
    output_data: List[str] = Field(
        default_factory=list, description="Results or outputs generated by the process."
    )

    def __hash__(self):
        return hash(self.uuid)

    def __eq__(self, other):
        return isinstance(other, Process) and self.uuid == other.uuid


class DataStore(Node):
    """
    Represents a data storage component within the system.
    It tracks the data written to and retrieved from the store.
    """

    data_inputs: List[str] = Field(
        default_factory=list, description="List of data written to the store."
    )
    data_outputs: List[str] = Field(
        default_factory=list, description="List of data retrieved from the store."
    )

    def __hash__(self):
        return hash(self.uuid)

    def __eq__(self, other):
        return isinstance(other, DataStore) and self.uuid == other.uuid


class TrustBoundary(Component):
    """
    Defines a trust boundary within the system, grouping components that share a common security context.
    This helps delineate which components fall within the same security perimeter.
    """

    component_uuids: List[UUID] = Field(
        default_factory=list,
        description="Set of component_uuids within this trust boundary, referencing existing components.",
    )

    def model_dump(self, **kwargs):
        data = super().model_dump(**kwargs)
        data["component_uuids"] = [str(id) for id in self.component_uuids]

        return data

    def __hash__(self):
        return hash(self.uuid)

    def __eq__(self, other):
        return isinstance(other, TrustBoundary) and self.uuid == other.uuid


class AgentDataFlowReport(BaseModel):
    """
    Provides a comprehensive report of the system's data flows.
    This includes an overview and detailed lists of external entities, processes, data stores, and trust boundaries.
    """

    overview: str = Field(
        default="No overview provided.", description="Overview of the data flow report."
    )
    external_entities: List[ExternalEntity] = Field(
        default_factory=list,
        description="A set of external entities interacting with the system.",
    )
    processes: List[Process] = Field(
        default_factory=list, description="A set of processes in the system."
    )
    data_stores: List[DataStore] = Field(
        default_factory=list,
        description="A set of data stores locations in the system.",
    )

    trust_boundaries: List[TrustBoundary] = Field(
        default_factory=list,
        description="A set of trust boundaries in the system.",
    )

    def __hash__(self):
        return hash(self.overview)

    def __eq__(self, other):
        if not isinstance(other, AgentDataFlowReport):
            return False
        return self.overview == other.overview

    def to_markdown(self) -> str:
        """
        Render the base DataFlowReport sections (overview, external entities, processes,
        data stores, and trust boundaries) as a Markdown-formatted string.
        """
        lines = []
        # Overview
        lines.append(f"# Data Flow Report\n")
        lines.append(f"**Overview:** {self.overview}\n")

        # External Entities
        if self.external_entities:
            lines.append("## External Entities\n")
            for e in self.external_entities:
                lines.append(e.to_markdown())
                if getattr(e, "data_flows", None):
                    lines.append("  - Data Flows:")
                    for df in e.data_flows:
                        lines.append(df.to_markdown())
            lines.append("")

        # Processes
        if self.processes:
            lines.append("## Processes\n")
            for p in self.processes:
                lines.append(p.to_markdown())
                if getattr(p, "input_data", None):
                    lines.append(f"  - Inputs: {', '.join(p.input_data)}")
                if getattr(p, "output_data", None):
                    lines.append(f"  - Outputs: {', '.join(p.output_data)}")
                if getattr(p, "data_flows", None):
                    lines.append("  - Data Flows:")
                    for df in p.data_flows:
                        lines.append(df.to_markdown())
            lines.append("")

        # Data Stores
        if self.data_stores:
            lines.append("## Data Stores\n")
            for ds in self.data_stores:
                lines.append(ds.to_markdown())
                if getattr(ds, "data_inputs", None):
                    lines.append(f"  - Data Inputs: {', '.join(ds.data_inputs)}")
                if getattr(ds, "data_outputs", None):
                    lines.append(f"  - Data Outputs: {', '.join(ds.data_outputs)}")
                if getattr(ds, "data_flows", None):
                    lines.append("  - Data Flows:")
                    for df in ds.data_flows:
                        lines.append(df.to_markdown())
            lines.append("")

        # Trust Boundaries
        if self.trust_boundaries:
            lines.append("## Trust Boundaries\n")
            for tb in self.trust_boundaries:
                lines.append(f"- **{tb.name}** (UUID: {tb.uuid}): {tb.description}")
                if getattr(tb, "component_uuids", None):
                    component_names = []
                    for comp in (
                        self.external_entities + self.processes + self.data_stores
                    ):
                        if comp.uuid in tb.component_uuids:
                            component_names.append(comp.name)
                    lines.append(f"  - Components: {', '.join(component_names)}")
            lines.append("")

        return "\n".join(lines)

    class Config:
        from_attributes = True
        json_schema_extra = {
            "example": {
                "overview": "This is an example of a data flow report.",
                "external_entities": [
                    {
                        "uuid": "uuid_1",
                        "name": "User",
                        "description": "A person interacting with the system.",
                        "data_flows": [
                            {
                                "uuid": "uuid_2",
                                "name": "User Login Flow",
                                "description": "Data flow from the client to authentication process.",
                                "destination_uuid": "uuid_3",
                                "data_type": "Login Credentials",
                                "direction": "outgoing",
                            }
                        ],
                    }
                ],
                "processes": [
                    {
                        "uuid": "uuid_3",
                        "name": "Authentication",
                        "description": "Handles user login.",
                        "input_data": ["Username", "Password"],
                        "output_data": ["JWT Token"],
                        "data_flows": [
                            {
                                "uuid": "uuid_5",
                                "name": "User Login Flow",
                                "description": "Data flow from the frontend to authentication service.",
                                "destination_id": "uuid_4",
                                "data_type": "Login Credentials",
                                "direction": "outgoing",
                            },
                            {
                                "uuid": "uuid_6",
                                "name": "Authentication Flow",
                                "description": "Data flow from the authentication service to the user",
                                "destination_uuid": "uuid_1",
                                "data_type": "Authentication Token",
                                "direction": "outgoing",
                            },
                        ],
                    }
                ],
                "data_stores": [
                    {
                        "uuid": "uuid_4",
                        "name": "User Database",
                        "description": "Stores all user data.",
                        "data_inputs": ["User registration details"],
                        "data_outputs": ["User authentication details"],
                        "data_flows": [
                            {
                                "uuid": "uuid_7",
                                "name": "User Login Data",
                                "description": "Data flow from the data store service to the authentication process.",
                                "destination_uuid": "uuid_2",
                                "data_type": "Authentication Token",
                                "direction": "outgoing",
                            }
                        ],
                    }
                ],
                "trust_boundaries": [
                    {
                        "uuid": "uuid_8",
                        "name": "User Boundary",
                        "description": "Separates the client-side interface.",
                        "component_uuids": [
                            "uuid_1",
                        ],
                    },
                    {
                        "uuid": "uuid_5",
                        "name": "Application Boundary",
                        "description": "Separates the backend-side interface.",
                        "component_uuids": [
                            "uuid_2",
                            "uuid_3",
                        ],
                    },
                ],
            }
        }


class DataFlowReport(AgentDataFlowReport):
    """
    Extends AgentDataFlowReport by including metadata related to file review processes.
    This model adds unique identifiers and categorizes files based on their review status.
    """

    uuid: UUID = Field(
        default_factory=uuid4, description="Unique identifier for the data flow report."
    )
    repository_uuid: Optional[UUID] = Field(
        default=None,
        description="Unique identifier for the repository. Null if this report is merged from multiple repositories.",
    )
    should_review: List[File] = Field(
        default_factory=list, description="Set of Files requiring review."
    )
    reviewed: List[File] = Field(
        default_factory=list, description="Set of Files that have been reviewed."
    )
    could_review: List[File] = Field(
        default_factory=list, description="Set of Files that could be reviewed."
    )
    should_not_review: List[File] = Field(
        default_factory=list, description="Set of Files that should not be reviewed."
    )
    could_not_review: List[File] = Field(
        default_factory=list, description="Set of Files that could not be reviewed."
    )
    diagram: str = Field(
        default="",
        description="A string representation of the diagram for visualization purposes.",
    )
    threats: List[Threat] = Field(
        default_factory=list, description="List of threats identified in the report."
    )
    attacks: List[Attack] = Field(
        default_factory=list, description="List of attacks identified in the report."
    )

    def __hash__(self):
        return hash(self.uuid)

    def __eq__(self, other):
        return isinstance(other, DataFlowReport) and self.uuid == other.uuid

    def model_dump(self, **kwargs):
        data = super().model_dump(**kwargs)
        data["uuid"] = str(self.uuid)
        data["repository_uuid"] = (
            str(self.repository_uuid) if self.repository_uuid is not None else None
        )

        return data

    def to_markdown(self) -> str:
        """
        Render this DataFlowReport instance as a Markdown-formatted string.
        """
        # Begin with base sections from AgentDataFlowReport
        base_md = super().to_markdown()
        lines = base_md.splitlines()

        # Report Metadata
        lines.append("## Report Metadata")
        lines.append(f"- UUID: {self.uuid}")
        lines.append(f"- Repository UUID: {self.repository_uuid}\n")

        # Files Review Status
        lines.append("## Files Review Status\n")
        lines.append(f"- Should Review ({len(self.should_review)}):")
        for f in self.should_review:
            lines.append(f"  {f.to_markdown()}")
        lines.append(f"- Reviewed ({len(self.reviewed)}):")
        for f in self.reviewed:
            lines.append(f"  {f.to_markdown()}")
        lines.append(f"- Could Review ({len(self.could_review)}):")
        for f in self.could_review:
            lines.append(f"  {f.to_markdown()}")
        lines.append(f"- Should Not Review ({len(self.should_not_review)}):")
        for f in self.should_not_review:
            lines.append(f"  {f.to_markdown()}")
        lines.append(f"- Could Not Review ({len(self.could_not_review)}):")
        for f in self.could_not_review:
            lines.append(f"  {f.to_markdown()}")
        lines.append("")  # blank line

        # Diagram
        lines.append("## Diagram")
        lines.append("```")
        lines.append(self.diagram)
        lines.append("```")

        # Threats
        if self.threats:
            lines.append("## Threats")
            for t in self.threats:
                lines.append(f"- **{t.name}** (UUID: {t.uuid}): {t.description}")
            lines.append("")

        # Attacks
        if self.attacks:
            lines.append("## Attacks")
            for a in self.attacks:
                lines.append(
                    f"- **{a.technique_name}** (ID: {a.technique_id}, Tactic: {a.attack_tactic}) against {a.component}"
                )
            lines.append("")

        return "\n".join(lines)

    class Config:
        from_attributes = True
